---
title: 1092-交大-作業系統總整與實作
date: 2021-02-26 12:47:12
tags:
- NCTU
- Operating System
category:
- Operating System
---

* [Introduction](#Introduction)
* [Week1 - Before OSDI](#Week1-Before-OSDI)
* [Week2 - Booting](#Week2-Booting)
* [Week3 - Interrupt and Interrupt Handling I](#Week3-Interrupt-and-Interrupt-Handling-I)
* [Week4 - Interrupt and Interrupt Handling II](#Week4-Interrupt-and-Interrupt-Handling-II)
* [Week5 - Process Management I](#Week5-Process-Management-I)
* [Week6 - Process Management II](#Week6-Process-Management-II)

<!--more-->

---


## Introduction

**待補**

---

## Week1 - Before OSDI

<font color='red'>**OS 根本上就是支巨大且複雜的程式、Application**</font>

開發 OS 與大型軟體程式的開發相似但牽涉到領域知識太多，基本上幾乎是把 CS 學過的各種知識彙整並應用
在念 CS 領域大部分也都會有寫 OS 的人通常都是各種大神才能應付的領域
這門課程會將許多在學習 CS 過程中大家較為模糊的區塊以及概念拿出來討論
小弟在寫這篇文章的時候也會跟著每周上課進度以及 lab 的進度做撰寫，如果有錯誤的部分也歡迎大家一起在留言區討論

在大型的軟體與程式開發之前需要大致上了解一下幾個區塊

* [Kernel Space and User Space](#Kernel-Space-and-User-Space)
* [Host computer and Target computer](#Host-computer-and-Target-computer)
* [Editor](#Editor)
* [Compiler](#Compiler)
* [Assembler](#Assembler)
* [Library](#Library)
* [Linker](#Linker)
* [Executable File](#Executable-File)
* [Memory](#Memory)
* [Makefile](#Makefile)
* [Autoconf tool](#Autoconf-tool)
* [Debugger](#Debugger)
* [Simulator Enumerator VM](#Simulator-Enumerator-VM)
* [Version Control](#Version-Control)


### Kernel Space and User Space

我們先前在 OS 的課程中學過，程式的執行區塊會分為 Kernel space 以及 User space ，一般撰寫的 code 都會在 User space 中編譯並執行
而本門課的內容是 OS code 的撰寫，因此大多時候都會在 Kernel space 進行作業

Kernel Space 可以想成在電腦執行工作的管理階層，擁有較大的權限、處理電腦運行過程中所需要決定的事項
管理階層也有他們需要執行的工作，例如:決定工作地點(管理記憶體)、安排工作順序(Schedule)...

User Space 的權利較小，主要執行一般應用程式，如果需要使用到系統資源等功能就須使用 <font color='red'>System call</font> 請 Kernel 代為執行

因此 Kernel Space 會有自己的 Library 在撰寫時不會用到 User Space 的 Library 在 User Space 寫 code 也是相同的情況

### Host computer and Target computer

Host computer定義為目前你正在寫 code 的電腦，要將寫完的 code 可以在 Target computer 上 run 起來
這個 Target computer 不一定要是實體的電腦，也可能是 Simulator, VM, ... 等模擬環境

### Editor

我想這個大家應該很熟悉，指的是單純的編輯器，在寫 code 的時候需要有一些能夠寫 code 地方，就是透過 Editor，也算是 IDE 的前身
常用的 IDE 例如: Visual Studio Code, Code Blocks, InteliJ...
常用的 Editor 例如: Notepad++, Vim, ...

Editor 如同 OS 一樣也是由他人透過程式寫出來的，因此也會有它的 source code 以及編譯他的 Compiler

### Compiler

大部分情況下我們所寫的 source code 是屬於高階語言(C, Java, ...)
我們必需透過編譯器(Compiler)將程式碼轉成 Low level 的 Machine code 才能夠讓電腦有辦法看懂，例如: gcc 編出來的 .o 檔
在 Compile 前也有可能會有 Preprocessor 的參與，以 C 的 Preprocesser 來說就是處理 # 開頭的 code

### Assembler

組合語言的 Compiler ，將組合語言編成 Machine code
組合語言本身就較高階語言 Low level 些，處理的工作也較為底層，但一樣要轉為最後的 Machine code 再執行

### Library

在寫 code 過程中有些重複常用的功能就會被包成 library 方便使用
因此 library 可以視為已經先幫你編好功能的 code 可以讓你自由使用
例如: C 語言常用的標準函示庫 stdlib.h

### Linker

當 source code 被編成 .o 檔之後將要透過 Linker 將各個零散的 .o 檔以及用到的 library link 在一起產生最後的可執行檔
<font color='red'>link 過程中主要決定的是將各個 .o 檔裡面程式沒有決定位置的部分連結在一起，以及一些外部符號等進行解析(C 的 extern)</font>
例如:A Program 用到 B Program 的 Function，原先在 A Program 這個部分的位置並沒有確定，因此就要透過 Linker 決定位置

在提到 link 過程中最常提到的也就是 Static link 與 Dynamic link

* Static link 
在編譯、連結階段就會將 lib 直接編入，佔空間但速度快

* Dynamic link
在程式執行階段才會載入 lib，不佔空間但速度較慢

最後補充一下 Linker 是由 linker script 所組成

### Executable File

Linker link 完的檔案(a.out)便是可執行檔，一般存於硬碟中
而 Executable file 的內容大致從上到下會有

<div style='width:50%;'>
{% asset_img Elf-layout.png %}
</div>

* ELF Header (Executable and Linkable Format) 標頭檔
* Program-Header Table
* .text 存放程式
* .rodata 存放唯讀資料
* .data 存放已初始化的 global variables
* .bss 存放未出化的 global variables

### Memory

當程式執行時，會有 loader 將硬碟中的 Executable file 解析並放進 Memory 裡面待 CPU 執行
這部分的架構如下，大家應該是差不多看到爛掉了

{% asset_img memoryLayoutC.jpg memoryLayout %}

記憶體從最下面是 0x0000 到上面 0xffff
最下面的 text 放程式碼
再來先放 initialized data 再放 uninitialized data
之後是 heap 從下往上放，放動態記憶體，例如:malloc, new
最後從上往下放的是 stack ，包含 local variable 或是 recursive 的 code(遞迴會爆掉就是這塊壓到下面的空間)

<font color='red'>最後在這邊整理一下完成程式的執行過程</font>

* 先將原始碼(source code, assembly source code)經過 preprocesser 以及 Compiler, Assembler 編成 .o 檔
* 將 .o 檔與 lib 透過 link 連結成可執行檔(a.out)存到硬碟等待執行
* Loader 將硬碟中的可執行檔解析並搬至記憶體中再交給 CPU 執行

### Makefile

當 Program 的程式量越來越大的時候，我們如果一個一個手動編成 .o 檔還要自己 link 是非常費神且沒有效率的事情
因此我們可以透過撰寫 Makefile 來幫我們自動化的進行這些動作，並依照是否有修改檔案決定是否需要重新 compile 與 link

### Autoconf tool

在我們完成 program 後，我們會希望他在各個平台都有辦法執行
因此 Autoconf tool 可以幫我們做各平台檢查與轉換的工作

### Debugger

基本上寫 code 的過程中不可能會沒寫出 bug，因此我們需要 debugger 來輔助我們能更方便的找出程式在哪裡當掉
debugger 能夠找到這些資訊的原理為
 <font color='red'>debugger 會將我們寫好的程式編出來之後抹掉一個 Byte，並且告訴 CPU 說遇到這些部分當掉就跳過去找他</font>

我們就可以在這樣的情況下取得當下程式的資訊(Callstack)

另外要提到的是在 User space 的 debugger 會由 kernel space 執行
那 Kernel space 的 debugger 怎麼辦?
聽說當初最早的創作人表示，如果會寫出 bug 就不要寫 kernel XD
不過由於我們都是普通人，因此現在還是有一些小程式可以輔助我們 debug，但這些 debugger 該怎麼 debug 就不要問我了

常見的 Debugger 有: gdb, kgdb, ...

### Simulator Enumerator VM

大致上理解的分別如下

* Simulator 看起來跟正常環境一樣，但其實內容並不一樣
* Enumerator 看起來跟正常環境一樣，內容也做得幾乎一樣，但也有可能透過其他方法達成一樣的效果
* VM(Virtual Machine) 透過真正的環境切出部份資源產生出模擬環境，基本上與真正環境無異

### Version Control

在多人大型軟體開發的情況下版本控制有多重要應該不用多做說明了
版本控制的原理主要是在每次更新的時候存下相異的部分(如果整個檔案重存太耗資源)
如果沒多人修改同一個檔案就直接將相異部分 merge 就好
如果有多人修改同一個檔案就先去打一架決定要用誰的再合併

常見有: git, SVN, ...

---

## Week2 - Booting

<font color='red'>**本周介紹的內容由按下開機鍵之後到你可以登入開始使用電腦的過程中發生了哪些事**</font>

按下開機鍵 -> 喚醒 CPU -> CPU 到指定的 Permanen Memory(通常是ROM) 拿第一個程式 (Bootloader1)
-> Bootloader1 做初步的初始化以及喚醒一些可以 drive 各個裝置的 Program (Bootloader2)
-> Bootloader2 將 device 內 load OS 的 Program 讀出來 (Bootloader3)
-> Bootloader3 將 OS load 出來執行 (Bootloader4)
-> Bootloader4(OS) 執行使用者需要的各種 Program


### Bootloader1

<font color='red'>CPU 剛被喚醒後並不清楚外面環境(device)的任何狀況，會先到指定的 Memory 位置執行指定的 Program，也就是 Bootloader1</font>
SoC(System on Chip)，因此會找指定的 Memory(ROM) 去執行 Program
因此在出廠的時候就已經燒在 firmware 上
這個 Program 會將部分參數初始化後並檢查周邊的 hardware 狀況
可能會提供簡單的 Shell 提供使用(ex:x86/BIOS)
將 device 內的 Program(Bootloader2) load 進 Memory 並將主導權轉交給 Bootloader2

### Bootloader2

將 OS 的 loader 給 load 進 Memory
可能提供簡單的 Shell 提供使用(選擇何種 OS 開機)
不是所有裝置都有這個部分的 Bootloader(ex:Smart Phone 開機時就已經決定是 Android 或是 IOS)
到目前為止都是在絕對位置去取得所需的資料，CPU 還不認得 filesystem
將主導權交給 Bootloader3

### Bootloader3

將 OS load 進 Memory 並作一些初始化
load kernel, 各種 table, schedulder 等 Program
將主導權交給 OS(Bootloader4)

### Bootloader4

OS 執行 Shell 提供 User 可以進行各種指令與程式的執行(fork)

---

## Week3 Interrupt and Interrupt Handling I

CPU 的 Interrupt 常用於 Device Driver 上或是各種服務的中斷與執行

### Device Driver

Driver 被定義為驅動各種裝置的 Program
Device 會透過物理上的連接(PIN)將訊號送到 bus 上
Assembly 透過正確的溝通方式(Protocal)對於 device 做操作
IO device 會佔據 Memory 區塊讓 OS 對此段 Memory 操作時對 device 發訊號
CPU 不會直接與 device 溝通(浪費資源)，會先與 Controller 溝通再由 Controller 對 device 發訊號

### Interrupt

在 CPU 工作時如果用無限迴圈去 handle IO 訊號相當浪費資源，因此在用新訊號出現時再透過 Interrupt 告知 CPU 有事情需處理
CPU 在處理完目前的工作時就會接著處理 Interrupt 內的訊息

### Exception

通常我們會將軟體上的 Interupt (Software Interrupt) 稱為 Exception
而如果只說 Intterupt 通常指硬體上線路升為 high 與對應的處理
兩者的後續的行為大致相同(查 vector table 做對應的 handler)
Exception 的例子: Divid by Zero

---

## Week4 Interrupt and Interrupt Handling II

### PIC

各種 device 會將線路連接到 PIC (Programmable inerrupt controller) 再透過 PIC 連接到 CPU 
當有新的 interrupt 訊號進來，device 會將線路升成 high 再透過 PIC 送給 CPU
PIC 也可能有多個串聯、並聯
CPU 收到 Interrupt 訊號會先將當前的事項處理完或是將 context 存下後，先查看是何種編號的 interrupt 再查詢 vector table 做對應處置
vector table 的內容擺放 jump 到對應執行的程式碼 (Interrupt Handler)

### Exception timing

Interrupt 的整個過程 (Interrupt response time) 會包含 Interrupt lantency 與 Processing time
Interrupt lantency 為 device 送出訊號直到 CPU 收到訊號中間的時間，IO 需要點時間延遲送進 CPU
Processing time 為 CPU 開始執行對應的程式碼，可以透過撰寫者控制執行速度

### Interrupt Handler

Interrupt Handler 大致會分為 Top Half 與 Bottom Half (概念上的設計方式)
某些 device 需要即時性的處理(例如網卡收封包)，就會在 Interrupt 之後在 Top Half 的部分先做處理
在 Top Half 的執行過程中，也有機會被 Priorty 較高的 Interrupt 所打斷
而封包的解析並沒有這麼的需要即時性，因此會先讓 CPU 回去處理原本的事物並接受其他 Interrupt
並將封包的處理排進 scedule 內等待處理，後半段處理的部分我們稱為 Bottom Half
透過上述的概念我們可以知道 Interrupt Handler 的執行可能會分散在 CPU 的工作時間內

### Driver

當有新的 driver 進出時，會有 init 與 cleanup 的 module 讓 OS 去註冊
driver 會由許多定義好的 API 所組成，將 function 對應到 OS 的執行工作表上
例如當 OS 執行 write 時，就會將 function 對應到 C: 或是 D: 上 driver 的 API 執行

### Softirq

Softirq 為 linux 系統提供的功能(Library)，起因是由於 Interrupt 之間存在許多互相打斷等等複雜的關係，因此 Linux 提供這項功能讓撰寫者能更方便的使用
Interrupt Handler 可以透過 Softirq 的方式執行，撰寫者必須 follow softirq 的建議的撰寫方法達到執行快速的效果
Softirq 內部會幫你做些整理或是排程，有可能把 Bottom Half 的部分在不同的 CPU 上去執行...等等
這些內部事項都是為了讓執行起來更快更有效率而做

舉例來說，假設 Softirq 內是空的時發生了 Interrupt A 之後在 Interrupt A 的 Bottom Half 執行時發生了 Interrupt B
完整的過程為 
origin program -> Interrupt A -> A Top Half -> Softirq(目前只有 Interrupt A) -> A Bottom Half
-> Interrupt B -> B Top Half -> Softirq(裡面有 Interrupt A, B) -> A Bottom Half
-> Softirq(只剩 Interrupt B) -> B Bottom Half -> Softirq(空了) -> origin program 

### Tasklet

常被 Softirq 拿來比較的 Tasklet 為 Softirq 裡面的一項功能
就我的理解，Tasklet 就像是一個小的 Softirq 並且在 Softirq 裡面參與排程
相對較不重要的 program bottom half 就會被丟到 Tasklet 裡面
Softirq 在排程的過程中也會執行到 Tasklet 這個功能，Tasklet 就會去看自己裡面有哪些待執行的 Bottom Half 並且排程後執行
例如 printer 的執行速度較不重要，就可以被丟到 Tasklet 裡面，待重要的部分執行完後再由 Tasklet 將一群都沒有很重要的排程後執行

---

## Week5 Process Management I

OS 讓 CPU 執行 user 的指令經過以下步驟

**CPU 跑第一個 Program A(init)**
**-> System call 請求 load Program B**
**-> OS 幫忙處理 Program, process, thread**
**-> OS Fork Program B** 
**-> Execute**
**-> OS schedule**
**-> Context switch**
**-> CPU 執行 Program B**

### OS runs the first Program

CPU 在開機之後，把 OS load 進來並 init 之後，等待 user 指令

### System Call

<font color='red'>在某些程式執行的過程中會需要使用到某些 lib 裡面包含較危險、敏感的資料與操作(fork, open, ...)</font>
因此這些 lib 內會透過 System Call 讓 OS 幫你完成這些指令

目前 x86 使用 Exception 的方式，使 CPU 中斷去執行指定的服務
<font color='red'>Exception 可以被理解為一道道被預設在 CPU 內的指令(Unknown Instruction, Divied by Zero, ...)</font>
OS 會在開機的時候將 Exception 對應的指令放在記憶體內(Vector Table)
當 CPU 執行 Program 的過程中觸發了某些意外 Exception 就會透過 Vector Table 去執行對應的指令

### Process Context

在不同 Process 執行時會自己有相關的資料需要紀錄(Context)
在 CPU 執行指令時，如果有 System Call 進入 Kernel Space 不算是 Context Switch 最多只有更改 mode

### Kernel Space and User Space

User space 與 Kernel Space 實際上放在記憶體的兩個區塊
User space 與 Kernel Space 各有自己的 stack (User stack, Kernel stack)
在不同的 space 執行會把 sp (stack pointer) 指到自己 space 的 stack 上

不同指令需要的權限不同，因此也會依權限將指令分為 Kernel mode 與 User mode 來管理
Kernel mode 與 User mode 的狀態為 CPU 在硬體上的狀態轉換，當在 Kernel mode 的底下，CPU 就能辦到更多的事情(傭有更多的權限)

### Program and Process

在 Disk 裡面尚未執行的 Elf files(Execute file)，稱為 Program
將 Program load 到 Memory 裡面執行，稱為 Process

### Fork

在 Program A 透過 OS fork 出 Program B 的時候會紀錄在 OS 的 Task structe 內
此 data structure 用來記錄執行時的相關資訊(discriptor, PID, parent, ...)，以及執行狀態(也會用於 schedule)

---

## Week6 Process Management II

### Context Switch

Context Switch 指的是在不同 Process 之間的切換需要有相關資料的備份，與執行到的位置等等的儲存，實際上為 register 的備份行為
Context Switch 的過程必定是比只做一件事耗時的，但目前為了使用者體驗的原因(ex:一邊播音樂、一邊寫報告)
因此會使用 Context Switch 讓多個工作都能輪流被執行到
原則上應該使 Context Switch 的時間佔執行工作的比例較少的 % 數，否則 CPU 可能會一直在執行 Context Switch 不怎麼執行工作導致效率差

### Interrupt Context

在 Interrupt 時，因為要求速度快且有會馬上回原 Program 的假設
因此僅有部分的 Context 儲存與備份，但並不是完整的 Context Switch，也通常不稱為 Context Switch
(Ex:收到網路封包 Interrupt 到分析確定是哪個 Program 的封包之前就屬於 Interrupt Context)

### Scheduler

在多個程式之間的切換與執行需要優先度、執行時間等等的安排，這邊所依靠的就是 Scheduler
在一般的 Process 開始執行前，Kernel 會加上 Timer Interrupt，每隔一段時間就會打進 User 的程式，就有機會被 Scheduler switch 掉
又或者是 User Program call 到任一 System Call 都有可能藏有 Scheduler 的呼叫在裡面，讓 Kernel 有機會將你 switch 掉

通常 IO bound 的 Process 優先度會較高(因為較高機會是 Interactive 的 Process，ex:browser)
各種 OS ，各種版本，Schedule 的方法都可能會有些差異

### User preemption

作業系統是否有將 User Process Interrupt 後切換成另一個 User Process 的能力 (較簡單)

### Kernel preemption

作業系統是否有在 User Process 透過 System Call 進入 Kernel 後 Interrupt 成另一個 User Process 的能力 (較困難)

### Process and Thread

如果今天開了很多個 word process，每個都要完整的資料結構會浪費空間
因此 thread 的用途就會將程式的部分重用，資料的部分 copy on write 以節省資源