---
title: 1092-交大-作業系統總整與實作
date: 2021-02-26 12:47:12
tags:
- NCTU
- Operating System
category:
- Operating System
---

* [Introduction](#Introduction)
* [Week1 - Before OSDI](#Week1-Before-OSDI)
* [Week2 - Booting](#Week2-Booting)
* [Week3 - Process Management I](#Week3-Process-Management-I)

<!--more-->

---


## Introduction

**待補**

---

## Week1 - Before OSDI

<font color='red'>**OS 根本上就是支巨大且複雜的程式、Application**</font>

開發 OS 與大型軟體程式的開發相似但牽涉到領域知識太多，基本上幾乎是把 CS 學過的各種知識彙整並應用
在念 CS 領域大部分也都會有寫 OS 的人通常都是各種大神才能應付的領域
這門課程會將許多在學習 CS 過程中大家較為模糊的區塊以及概念拿出來討論
小弟在寫這篇文章的時候也會跟著每周上課進度以及 lab 的進度做撰寫，如果有錯誤的部分也歡迎大家一起在留言區討論

在大型的軟體與程式開發之前需要大致上了解一下幾個區塊

* [Kernel Space and User Space](#Kernel-Space-and-User-Space)
* [Host computer and Target computer](#Host-computer-and-Target-computer)
* [Editor](#Editor)
* [Compiler](#Compiler)
* [Assembler](#Assembler)
* [Library](#Library)
* [Linker](#Linker)
* [Executable File](#Executable-File)
* [Memory](#Memory)
* [Makefile](#Makefile)
* [Autoconf tool](#Autoconf-tool)
* [Debugger](#Debugger)
* [Simulator Enumerator VM](#Simulator-Enumerator-VM)
* [Version Control](#Version-Control)


### Kernel Space and User Space

我們先前在 OS 的課程中學過，程式的執行區塊會分為 Kernel space 以及 User space ，一般撰寫的 code 都會在 User space 中編譯並執行
而本門課的內容是 OS code 的撰寫，因此大多時候都會在 Kernel space 進行作業

Kernel Space 可以想成在電腦執行工作的管理階層，擁有較大的權限、處理電腦運行過程中所需要決定的事項
管理階層也有他們需要執行的工作，例如:決定工作地點(管理記憶體)、安排工作順序(Schedule)...

User Space 的權利較小，主要執行一般應用程式，如果需要使用到系統資源等功能就須使用 <font color='red'>System call</font> 請 Kernel 代為執行

因此 Kernel Space 會有自己的 Library 在撰寫時不會用到 User Space 的 Library 在 User Space 寫 code 也是相同的情況

### Host computer and Target computer

Host computer定義為目前你正在寫 code 的電腦，要將寫完的 code 可以在 Target computer 上 run 起來
這個 Target computer 不一定要是實體的電腦，也可能是 Simulator, VM, ... 等模擬環境

### Editor

我想這個大家應該很熟悉，指的是單純的編輯器，在寫 code 的時候需要有一些能夠寫 code 地方，就是透過 Editor，也算是 IDE 的前身
常用的 IDE 例如: Visual Studio Code, Code Blocks, InteliJ...
常用的 Editor 例如: Notepad++, Vim, ...

Editor 如同 OS 一樣也是由他人透過程式寫出來的，因此也會有它的 source code 以及編譯他的 Compiler

### Compiler

大部分情況下我們所寫的 source code 是屬於高階語言(C, Java, ...)
我們必需透過編譯器(Compiler)將程式碼轉成 Low level 的 Machine code 才能夠讓電腦有辦法看懂，例如: gcc 編出來的 .o 檔
在 Compile 前也有可能會有 Preprocessor 的參與，以 C 的 Preprocesser 來說就是處理 # 開頭的 code

### Assembler

組合語言的 Compiler ，將組合語言編成 Machine code
組合語言本身就較高階語言 Low level 些，處理的工作也較為底層，但一樣要轉為最後的 Machine code 再執行

### Library

在寫 code 過程中有些重複常用的功能就會被包成 library 方便使用
因此 library 可以視為已經先幫你編好功能的 code 可以讓你自由使用
例如: C 語言常用的標準函示庫 stdlib.h

### Linker

當 source code 被編成 .o 檔之後將要透過 Linker 將各個零散的 .o 檔以及用到的 library link 在一起產生最後的可執行檔
<font color='red'>link 過程中主要決定的是將各個 .o 檔裡面程式沒有決定位置的部分連結在一起，以及一些外部符號等進行解析(C 的 extern)</font>
例如:A Program 用到 B Program 的 Function，原先在 A Program 這個部分的位置並沒有確定，因此就要透過 Linker 決定位置

在提到 link 過程中最常提到的也就是 Static link 與 Dynamic link

* Static link 
在編譯、連結階段就會將 lib 直接編入，佔空間但速度快

* Dynamic link
在程式執行階段才會載入 lib，不佔空間但速度較慢

最後補充一下 Linker 是由 linker script 所組成

### Executable File

Linker link 完的檔案(a.out)便是可執行檔，一般存於硬碟中
而 Executable file 的內容大致從上到下會有

<div style='width:50%;'>
{% asset_img Elf-layout.png %}
</div>

* ELF Header (Executable and Linkable Format) 標頭檔
* Program-Header Table
* .text 存放程式
* .rodata 存放唯讀資料
* .data 存放已初始化的 global variables
* .bss 存放未出化的 global variables

### Memory

當程式執行時，會有 loader 將硬碟中的 Executable file 解析並放進 Memory 裡面待 CPU 執行
這部分的架構如下，大家應該是差不多看到爛掉了

{% asset_img memoryLayoutC.jpg memoryLayout %}

記憶體從最下面是 0x0000 到上面 0xffff
最下面的 text 放程式碼
再來先放 initialized data 再放 uninitialized data
之後是 heap 從下往上放，放動態記憶體，例如:malloc, new
最後從上往下放的是 stack ，包含 local variable 或是 recursive 的 code(遞迴會爆掉就是這塊壓到下面的空間)

<font color='red'>最後在這邊整理一下完成程式的執行過程</font>

* 先將原始碼(source code, assembly source code)經過 preprocesser 以及 Compiler, Assembler 編成 .o 檔
* 將 .o 檔與 lib 透過 link 連結成可執行檔(a.out)存到硬碟等待執行
* Loader 將硬碟中的可執行檔解析並搬至記憶體中再交給 CPU 執行

### Makefile

當 Program 的程式量越來越大的時候，我們如果一個一個手動編成 .o 檔還要自己 link 是非常費神且沒有效率的事情
因此我們可以透過撰寫 Makefile 來幫我們自動化的進行這些動作，並依照是否有修改檔案決定是否需要重新 compile 與 link

### Autoconf tool

在我們完成 program 後，我們會希望他在各個平台都有辦法執行
因此 Autoconf tool 可以幫我們做各平台檢查與轉換的工作

### Debugger

基本上寫 code 的過程中不可能會沒寫出 bug，因此我們需要 debugger 來輔助我們能更方便的找出程式在哪裡當掉
debugger 能夠找到這些資訊的原理為
 <font color='red'>debugger 會將我們寫好的程式編出來之後抹掉一個 Byte，並且告訴 CPU 說遇到這些部分當掉就跳過去找他</font>

我們就可以在這樣的情況下取得當下程式的資訊(Callstack)

另外要提到的是在 User space 的 debugger 會由 kernel space 執行
那 Kernel space 的 debugger 怎麼辦?
聽說當初最早的創作人表示，如果會寫出 bug 就不要寫 kernel XD
不過由於我們都是普通人，因此現在還是有一些小程式可以輔助我們 debug，但這些 debugger 該怎麼 debug 就不要問我了

常見的 Debugger 有: gdb, kgdb, ...

### Simulator Enumerator VM

大致上理解的分別如下

* Simulator 看起來跟正常環境一樣，但其實內容並不一樣
* Enumerator 看起來跟正常環境一樣，內容也做得幾乎一樣，但也有可能透過其他方法達成一樣的效果
* VM(Virtual Machine) 透過真正的環境切出部份資源產生出模擬環境，基本上與真正環境無異

### Version Control

在多人大型軟體開發的情況下版本控制有多重要應該不用多做說明了
版本控制的原理主要是在每次更新的時候存下相異的部分(如果整個檔案重存太耗資源)
如果沒多人修改同一個檔案就直接將相異部分 merge 就好
如果有多人修改同一個檔案就先去打一架決定要用誰的再合併

常見有: git, SVN, ...

---

## Week2 - Booting

<font color='red'>**本周介紹的內容由按下開機鍵之後到你可以登入開始使用電腦的過程中發生了哪些事**</font>

按下開機鍵 -> 喚醒 CPU -> CPU 到指定的 Permanen Memory(通常是ROM) 拿第一個程式 (Bootloader1)
-> Bootloader1 做初步的初始化以及喚醒一些可以 drive 各個裝置的 Program (Bootloader2)
-> Bootloader2 將 device 內 load OS 的 Program 讀出來 (Bootloader3)
-> Bootloader3 將 OS load 出來執行 (Bootloader4)
-> Bootloader4(OS) 執行使用者需要的各種 Program


### Bootloader1

<font color='red'>CPU 剛被喚醒後並不清楚外面環境(device)的任何狀況，會先到指定的 Memory 位置執行指定的 Program，也就是 Bootloader1</font>
SoC(System on Chip)，因此會找指定的 Memory(ROM) 去執行 Program
因此在出廠的時候就已經燒在 firmware 上
這個 Program 會將部分參數初始化後並檢查周邊的 hardware 狀況
可能會提供簡單的 Shell 提供使用(ex:x86/BIOS)
將 device 內的 Program(Bootloader2) load 進 Memory 並將主導權轉交給 Bootloader2

### Bootloader2

將 OS 的 loader 給 load 進 Memory
可能提供簡單的 Shell 提供使用(選擇何種 OS 開機)
不是所有裝置都有這個部分的 Bootloader(ex:Smart Phone 開機時就已經決定是 Android 或是 IOS)
到目前為止都是在絕對位置去取得所需的資料，CPU 還不認得 filesystem
將主導權交給 Bootloader3

### Bootloader3

將 OS load 進 Memory 並作一些初始化
load kernel, 各種 table, schedulder 等 Program
將主導權交給 OS(Bootloader4)

### Bootloader4

OS 執行 Shell 提供 User 可以進行各種指令與程式的執行(fork)

---

## Week3 Process Management I

OS 讓 CPU 執行 user 的指令經過以下步驟

**CPU 跑第一個 Program A(init)**
**-> System call 請求 load Program B**
**-> OS 幫忙處理 Program, process, thread**
**-> OS Fork Program B** 
**-> Execute**
**-> OS schedule**
**-> Context switch**
**-> CPU 執行 Program B**


### OS runs the first Program

CPU 在開機之後，把 OS load 進來並 init 之後，等待 user 指令

### System Call

<font color='red'>在某些程式執行的過程中會需要使用到某些 lib 裡面包含較危險、敏感的資料與操作(fork, open, ...)</font>
因此這些 lib 內會透過 System Call 讓 OS 幫你完成這些指令

目前 x86 使用 Exception 的方式，使 CPU 中斷去執行指定的服務
<font color='red'>Exception 可以被理解為一道道被預設在 CPU 內的指令(Unknown Instruction, Divied by Zero, ...)</font>
OS 會在開機的時候將 Exception 對應的指令放在記憶體內(Vector Table)
當 CPU 執行 Program 的過程中觸發了某些意外 Exception 就會透過 Vector Table 去執行對應的指令

### Process Context

在不同 Process 執行時會自己有相關的資料需要紀錄(Context)
在 CPU 執行指令時，如果有 System Call 進入 Kernel Space 不算是 Context Switch 最多只有更改 mode

### Kernel Space and User Space

User space 與 Kernel Space 各有自己的 stack (User stack, Kernel stack)
在不同的 space 執行會把 sp (stack pointer) 指到自己 space 的 stack 上

不同指令需要的權限不同，因此也會依權限將指令分為 Kernel mode 與 User mode 來管理

### Program and Process

在 Disk 裡面尚未執行的 Elf files(Execute file)，稱為 Program
將 Program load 到 Memory 裡面執行，稱為 Process

### Fork

在 Program A 透過 OS fork 出 Program B 的時候會紀錄在 OS 的 Task structe 內
此 data structure 用來記錄執行時的相關資訊(discriptor, PID, parent, ...)，以及執行狀態(也會用於 schedule)

---